<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PromptRef - Notes & References</title>
    <script src="https://unpkg.com/marked@4.3.0/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            background: #f5f5f5;
        }

        .sidebar {
            width: 25%;
            min-width: 250px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            padding: 0;
            overflow: hidden;
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .app-title {
            cursor: pointer;
            color: #2196f3;
            transition: all 0.2s ease;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .app-title:hover {
            background: #e3f2fd;
            color: #1976d2;
            transform: translateY(-1px);
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            background: #2196f3;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1001;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .sidebar-toggle:hover {
            background: #1976d2;
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .delete-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            color: #666;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-button:hover {
            background: #f0f0f0;
            color: #d32f2f;
        }

        .delete-button:disabled {
            cursor: not-allowed;
            opacity: 0.3;
        }

        .delete-button:disabled:hover {
            background: none;
            color: #666;
        }

        .add-folder-header-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .add-folder-header-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .add-note-header-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .add-note-header-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .folder {
            margin-bottom: 20px;
        }

        .folder-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .folder-header:hover {
            background: #f0f0f0;
        }

        .folder-arrow {
            transition: transform 0.2s ease;
            font-size: 12px;
            color: #888;
        }

        .folder-arrow.expanded {
            transform: rotate(90deg);
        }

        .folder-notes {
            margin-left: 10px;
        }

        .folder-notes.collapsed {
            display: none;
        }

        .note-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            border-left: 3px solid transparent;
            user-select: none;
        }

        .note-item:hover {
            background: #f0f0f0;
        }

        .note-item.active {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .note-item.dragging {
            opacity: 0.5;
        }

        .folder.drop-target {
            background: #e8f5e8;
            border-radius: 4px;
        }

        .folder-header.drop-target {
            background: #e8f5e8 !important;
        }

        #folders-container {
            flex: 1;
            overflow-y: auto;
        }

        .add-controls {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid #eee;
            flex-shrink: 0;
        }

        .add-controls .input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .add-controls input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .add-controls .button-row {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 8px;
        }

        .add-controls button {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
        }

        .add-controls button:hover {
            background: #f0f0f0;
        }

        .add-controls .add-folder-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .add-controls .add-folder-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .add-controls .add-note-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .add-controls .add-note-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .main-content {
            flex: 1;
            display: flex;
            height: 100vh;
            min-width: 0;
        }

        .editor-pane {
            width: 50%;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .editor-header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            border-right: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .editor-header input {
            flex: 1;
            border: none;
            font-size: 18px;
            font-weight: 600;
            outline: none;
        }

        .mobile-controls {
            display: none;
            align-items: center;
            gap: 8px;
        }

        .editor-textarea {
            flex: 1;
            border: none;
            border-right: 1px solid #ddd;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            background: white;
        }

        .preview-pane {
            width: 50%;
            min-width: 300px;
            background: white;
            overflow-y: auto;
            padding: 20px;
        }

        .preview-content {
            max-width: none;
        }

        .preview-content h1, .preview-content h2, .preview-content h3 {
            margin-top: 24px;
            margin-bottom: 12px;
        }

        .preview-content p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .preview-content code {
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .preview-content pre {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .command-palette {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 300px;
        }

        .palette-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .palette-item:last-child {
            border-bottom: none;
        }

        .palette-item:hover, .palette-item.selected {
            background: #f0f0f0;
        }

        .palette-item.selected {
            background: #e3f2fd;
        }

        .copy-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #2196f3;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .copy-button:hover {
            background: #1976d2;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .copy-button.copied {
            background: #4caf50;
            transform: scale(1.05);
        }

        .bottom-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 1000;
        }



        .bottom-action-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .bottom-delete-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            color: #666;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .bottom-delete-button:hover {
            background: #f0f0f0;
            color: #d32f2f;
        }

        .bottom-delete-button:disabled {
            cursor: not-allowed;
            opacity: 0.3;
        }

        .bottom-delete-button:disabled:hover {
            background: none;
            color: #666;
        }

        .bottom-add-folder-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .bottom-add-folder-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .bottom-add-note-btn {
            background: #2196f3;
            color: white;
            border: 1px solid #2196f3;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .bottom-add-note-btn:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #eee;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-body {
            line-height: 1.6;
        }

        .modal-body ul {
            margin: 0;
            padding-left: 20px;
        }

        .modal-body li {
            margin-bottom: 12px;
        }

        .modal-body a {
            color: #2196f3;
            text-decoration: none;
        }

        .modal-body a:hover {
            text-decoration: underline;
        }

        .reference-block {
            background: #f8f9fa;
            border-left: 4px solid #2196f3;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
        }

        .reference-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #1976d2;
        }

        .folder-header.selected {
            background: #e3f2fd;
            border-left: 3px solid #2196f3;
        }

        /* Mobile and tablet responsive design */
        @media (max-width: 1024px) {
            .sidebar {
                width: 30%;
                min-width: 200px;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 1000;
                width: 280px;
                min-width: 280px;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .main-content {
                width: 100%;
            }

            .editor-pane {
                width: 100%;
                min-width: 0;
            }

            .preview-pane {
                width: 100%;
                min-width: 0;
                display: none;
            }

            .preview-pane.show {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                z-index: 1002;
                padding-top: 60px;
            }

            .sidebar-toggle {
                display: flex;
                position: static;
                background: #2196f3;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                align-items: center;
                justify-content: center;
            }

            .mobile-controls {
                display: flex;
            }

            .editor-header {
                border-right: none;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                width: 100%;
                min-width: 100%;
            }

            .header-buttons {
                flex-wrap: wrap;
                gap: 4px;
            }

            .header-buttons button {
                font-size: 10px;
                padding: 3px 6px;
            }
        }

        .mobile-preview-toggle {
            background: #2196f3;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mobile-preview-toggle:hover {
            background: #1976d2;
        }



        .preview-close {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: #666;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1003;
        }

        .preview-pane.show .preview-close {
            display: block;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <h2>
            <span class="app-title" onclick="showHelpModal()" title="Click for help & info">PromptRef</span>
        </h2>
        <div id="folders-container"></div>
    </div>

    <div class="main-content">
        <div class="editor-pane">
            <div class="editor-header">
                <input type="text" id="note-title" placeholder="Note title...">
                <div class="mobile-controls">
                    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">
                        ☰
                    </button>
                    <button class="mobile-preview-toggle" onclick="showPreview()" title="Show preview">
                        👁
                    </button>
                </div>
            </div>
            <textarea id="editor" class="editor-textarea" placeholder="Start writing your note in markdown..."></textarea>
            <div id="command-palette" class="command-palette" style="display: none;"></div>
        </div>
        <div class="preview-pane" id="preview-pane">
            <button class="preview-close" onclick="hidePreview()">✕ Close</button>
            <div id="preview" class="preview-content"></div>
        </div>
    </div>

    <button class="copy-button" onclick="copyCurrentNote()">
        <span>📋</span>
        <span id="copy-text">Copy</span>
    </button>

    <div class="bottom-controls">
        <div class="bottom-action-buttons">
            <button id="bottom-delete-button" class="bottom-delete-button" onclick="deleteCurrentNote()" title="Delete selected note">
                🗑️
            </button>
            <button class="bottom-add-folder-btn" onclick="addNewFolder()" title="Add new folder">
                <span>📁</span>
                <span>Add</span>
            </button>
            <button class="bottom-add-note-btn" onclick="addNewNote()" title="Add new note">
                <span>📝</span>
                <span>Add</span>
            </button>
        </div>
    </div>

    <div id="help-modal" class="modal-overlay" onclick="hideHelpModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">Help & Info</h3>
                <button class="modal-close" onclick="hideHelpModal()">×</button>
            </div>
            <div class="modal-body">
                <ul>
                    <li>
                        <strong>Documentation:</strong> 
                        <a href="https://github.com/jakebmcc/PromptRef" target="_blank" rel="noopener noreferrer">
                            View README on GitHub
                        </a>
                    </li>
                    <li>
                        <strong>Feedback or questions?</strong> 
                        <a href="https://t.me/jakebmcc" target="_blank" rel="noopener noreferrer">
                            Telegram @jakebmcc
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Data structure and storage
        let data = {
            folders: {},
            folderMetadata: {}, // Store folder names and descriptions
            folderStates: {}, // Track expanded/collapsed state
            currentFolder: null,
            currentNote: null,
            selectedType: 'note', // Track whether a note or folder is selected
            pendingNewNote: null, // Track unmodified new notes for auto-deletion
            pendingNewFolder: null // Track unmodified new folders for auto-deletion
        };

        let paletteVisible = false;
        let paletteIndex = -1;
        let paletteQuery = '';
        let palettePosition = 0;

        // Load data from localStorage
        function loadData() {
            const saved = localStorage.getItem('promptref-data');
            if (saved) {
                data = JSON.parse(saved);
                // Ensure folderStates exists
                if (!data.folderStates) {
                    data.folderStates = {};
                }
                // Ensure folderMetadata exists
                if (!data.folderMetadata) {
                    data.folderMetadata = {};
                }
                // Initialize folderStates for any folders that don't have state
                Object.keys(data.folders).forEach(folderName => {
                    if (!(folderName in data.folderStates)) {
                        data.folderStates[folderName] = true; // Default to expanded
                    }
                    // Initialize folder metadata if missing
                    if (!(folderName in data.folderMetadata)) {
                        data.folderMetadata[folderName] = {
                            name: folderName,
                            description: ''
                        };
                    }
                });
            } else {
                // Initialize with sample data
                data.folders = {
                    'General': {
                        'Welcome Note': {
                            title: 'Welcome Note',
                            body: '# Welcome to PromptRef\n\nThis is your first note! Try:\n\n- Type `/` to reference other notes\n- Edit this markdown and see live preview\n- Create folders and notes from the sidebar\n- Use the Copy All button to copy the current note'
                        }
                    }
                };
                data.folderMetadata = {
                    'General': {
                        name: 'General',
                        description: 'Your general notes and ideas'
                    }
                };
                data.folderStates = {
                    'General': true
                };
                data.currentFolder = 'General';
                data.currentNote = 'Welcome Note';
                saveData();
            }
        }

        function saveData() {
            localStorage.setItem('promptref-data', JSON.stringify(data));
        }

        // UI Rendering
        function renderFolders() {
            const container = document.getElementById('folders-container');
            container.innerHTML = '';

            Object.keys(data.folders).forEach(folderName => {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'folder';
                folderDiv.setAttribute('data-folder', folderName);

                const headerDiv = document.createElement('div');
                headerDiv.className = 'folder-header';
                
                // Highlight selected folder
                if (data.selectedType === 'folder' && data.currentFolder === folderName) {
                    headerDiv.classList.add('selected');
                }
                
                const folderNameSpan = document.createElement('span');
                // Use display name from metadata, fallback to key name
                const displayName = data.folderMetadata[folderName]?.name || folderName;
                folderNameSpan.textContent = displayName;
                
                const arrowSpan = document.createElement('span');
                arrowSpan.className = 'folder-arrow';
                arrowSpan.textContent = '▶';
                if (data.folderStates[folderName]) {
                    arrowSpan.classList.add('expanded');
                }
                
                headerDiv.appendChild(folderNameSpan);
                headerDiv.appendChild(arrowSpan);
                
                // Handle folder header clicks - left side for selection, right side for toggle
                folderNameSpan.onclick = (e) => {
                    e.stopPropagation();
                    selectFolder(folderName);
                };
                arrowSpan.onclick = (e) => {
                    e.stopPropagation();
                    toggleFolder(folderName);
                };
                
                // Make folder header a drop target
                setupDropTarget(headerDiv, folderName);
                
                folderDiv.appendChild(headerDiv);

                const notesDiv = document.createElement('div');
                notesDiv.className = 'folder-notes';
                if (!data.folderStates[folderName]) {
                    notesDiv.classList.add('collapsed');
                }

                Object.keys(data.folders[folderName]).forEach(noteTitle => {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'note-item';
                    noteDiv.setAttribute('draggable', 'true');
                    noteDiv.setAttribute('data-note', noteTitle);
                    noteDiv.setAttribute('data-folder', folderName);
                    
                    if (data.selectedType === 'note' && data.currentFolder === folderName && data.currentNote === noteTitle) {
                        noteDiv.classList.add('active');
                    }
                    noteDiv.textContent = noteTitle;
                    noteDiv.onclick = () => selectNote(folderName, noteTitle);
                    
                    // Setup drag events
                    setupDragEvents(noteDiv, folderName, noteTitle);
                    
                    notesDiv.appendChild(noteDiv);
                });

                folderDiv.appendChild(notesDiv);
                container.appendChild(folderDiv);
            });
        }

        function toggleFolder(folderName) {
            data.folderStates[folderName] = !data.folderStates[folderName];
            saveData();
            renderFolders();
        }

        function setupDragEvents(noteDiv, folderName, noteTitle) {
            noteDiv.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    sourceFolder: folderName,
                    noteTitle: noteTitle
                }));
                noteDiv.classList.add('dragging');
            });

            noteDiv.addEventListener('dragend', function(e) {
                noteDiv.classList.remove('dragging');
                // Clear any drop targets
                document.querySelectorAll('.drop-target').forEach(el => {
                    el.classList.remove('drop-target');
                });
            });
        }

        function setupDropTarget(element, targetFolder) {
            element.addEventListener('dragover', function(e) {
                e.preventDefault();
                element.classList.add('drop-target');
            });

            element.addEventListener('dragleave', function(e) {
                element.classList.remove('drop-target');
            });

            element.addEventListener('drop', function(e) {
                e.preventDefault();
                element.classList.remove('drop-target');
                
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    const { sourceFolder, noteTitle } = dragData;
                    
                    if (sourceFolder !== targetFolder) {
                        moveNote(sourceFolder, noteTitle, targetFolder);
                    }
                } catch (err) {
                    console.error('Error handling drop:', err);
                }
            });
        }

        function moveNote(sourceFolder, noteTitle, targetFolder) {
            // Get the note data
            const note = data.folders[sourceFolder][noteTitle];
            
            // Remove from source folder
            delete data.folders[sourceFolder][noteTitle];
            
            // Add to target folder
            data.folders[targetFolder][noteTitle] = note;
            
            // Update current selection if the moved note was selected
            if (data.currentFolder === sourceFolder && data.currentNote === noteTitle) {
                data.currentFolder = targetFolder;
            }
            
            // Ensure target folder is expanded
            data.folderStates[targetFolder] = true;
            
            saveData();
            renderFolders();
        }

        function selectFolder(folderName) {
            // Clean up any pending items before switching
            cleanupPendingItems();
            
            data.currentFolder = folderName;
            data.currentNote = null;
            data.selectedType = 'folder';
            
            // Populate editor with folder data
            const folderData = data.folderMetadata[folderName] || { name: folderName, description: '' };
            document.getElementById('note-title').value = folderData.name;
            document.getElementById('editor').value = folderData.description;
            document.getElementById('preview').innerHTML = marked.parse(folderData.description);
            
            renderFolders();
            updateDeleteButton();
            saveData();
        }

        function selectNote(folderName, noteTitle) {
            // Clean up any pending items before switching
            cleanupPendingItems();
            
            data.currentFolder = folderName;
            data.currentNote = noteTitle;
            data.selectedType = 'note';
            const note = data.folders[folderName][noteTitle];
            
            document.getElementById('note-title').value = note.title;
            document.getElementById('editor').value = note.body;
            updatePreview();
            renderFolders();
            updateDeleteButton();
            saveData();
        }

        function updatePreview() {
            const body = document.getElementById('editor').value;
            const processedBody = processReferences(body);
            document.getElementById('preview').innerHTML = marked.parse(processedBody);
        }

        function processReferences(text) {
            return text.replace(/\{\{([^}]+)\}\}/g, (match, content) => {
                const lines = content.split('\n');
                const title = lines[0];
                const body = lines.slice(2).join('\n'); // Skip title and separator
                
                return `<div class="reference-block">
                    <div class="reference-title">${title}</div>
                    <div>${marked.parse(body)}</div>
                </div>`;
            });
        }

        // Note/Folder management
        function addFolder() {
            const input = document.getElementById('new-folder-input');
            const name = input.value.trim();
            if (name && !data.folders[name]) {
                data.folders[name] = {};
                data.folderStates[name] = true; // New folders start expanded
                data.folderMetadata[name] = {
                    name: name,
                    description: ''
                };
                input.value = '';
                renderFolders();
                saveData();
            }
        }

        function addNewFolder() {
            // Clean up any existing pending items
            cleanupPendingItems();
            
            // Create new folder with default name
            const folderName = 'New Folder';
            data.folders[folderName] = {};
            data.folderStates[folderName] = true; // New folders start expanded
            data.folderMetadata[folderName] = {
                name: folderName,
                description: ''
            };
            
            // Mark as pending for auto-deletion
            data.pendingNewFolder = folderName;
            
            // Select the new folder
            selectFolder(folderName);
        }

        function addNewNote() {
            // Clean up any existing pending items
            cleanupPendingItems();
            
            // Determine target folder
            let targetFolder = data.currentFolder;
            
            // If no folder is selected or selected item is not in a folder, use first available folder
            if (!targetFolder || !data.folders[targetFolder]) {
                const availableFolders = Object.keys(data.folders);
                if (availableFolders.length === 0) {
                    // No folders exist, create a default one
                    const defaultFolder = 'General';
                    data.folders[defaultFolder] = {};
                    data.folderStates[defaultFolder] = true;
                    data.folderMetadata[defaultFolder] = {
                        name: defaultFolder,
                        description: ''
                    };
                    targetFolder = defaultFolder;
                } else {
                    targetFolder = availableFolders[0];
                }
            }
            
            // Create new note with default title
            const noteTitle = 'New Note';
            data.folders[targetFolder][noteTitle] = {
                title: noteTitle,
                body: ''
            };
            
            // Mark as pending for auto-deletion
            data.pendingNewNote = {
                folder: targetFolder,
                note: noteTitle
            };
            
            // Select the new note
            selectNote(targetFolder, noteTitle);
        }

        function cleanupPendingItems() {
            cleanupPendingNewNote();
            cleanupPendingNewFolder();
        }

        function cleanupPendingNewNote() {
            if (data.pendingNewNote) {
                const { folder, note } = data.pendingNewNote;
                
                // Check if note still exists and is blank
                if (data.folders[folder] && data.folders[folder][note]) {
                    const currentTitle = document.getElementById('note-title').value.trim();
                    const currentBody = document.getElementById('editor').value.trim();
                    
                    // Delete if note is truly blank: no meaningful title AND no body content
                    const isBlankTitle = currentTitle === '' || currentTitle === 'New Note';
                    const isBlankBody = currentBody === '';
                    
                    if (isBlankTitle && isBlankBody) {
                        delete data.folders[folder][note];
                        
                        // If we just deleted the currently selected note, clear the editor
                        if (data.currentFolder === folder && data.currentNote === note) {
                            data.currentNote = null;
                            document.getElementById('note-title').value = '';
                            document.getElementById('editor').value = '';
                            document.getElementById('preview').innerHTML = '';
                        }
                        
                        // Update the sidebar to reflect the deletion
                        renderFolders();
                        saveData();
                    }
                }
                
                data.pendingNewNote = null;
            }
        }

        function cleanupPendingNewFolder() {
            if (data.pendingNewFolder) {
                const folderName = data.pendingNewFolder;
                
                // Check if folder still exists and is blank
                if (data.folders[folderName] && data.folderMetadata[folderName]) {
                    const currentTitle = document.getElementById('note-title').value.trim();
                    const currentBody = document.getElementById('editor').value.trim();
                    
                    // Delete if folder is truly blank: no meaningful name AND no description
                    const isBlankName = currentTitle === '' || currentTitle === 'New Folder';
                    const isBlankDescription = currentBody === '';
                    const hasNoNotes = Object.keys(data.folders[folderName]).length === 0;
                    
                    if (isBlankName && isBlankDescription && hasNoNotes) {
                        delete data.folders[folderName];
                        delete data.folderStates[folderName];
                        delete data.folderMetadata[folderName];
                        
                        // If we just deleted the currently selected folder, clear selection
                        if (data.currentFolder === folderName) {
                            data.currentFolder = null;
                            data.selectedType = 'note';
                            document.getElementById('note-title').value = '';
                            document.getElementById('editor').value = '';
                            document.getElementById('preview').innerHTML = '';
                        }
                        
                        // Update the sidebar to reflect the deletion
                        renderFolders();
                        saveData();
                    }
                }
                
                data.pendingNewFolder = null;
            }
        }

        function saveCurrentNote() {
            if (data.selectedType === 'folder') {
                saveFolderData();
                return;
            }
            
            if (data.currentFolder && data.currentNote) {
                const newTitle = document.getElementById('note-title').value.trim();
                const body = document.getElementById('editor').value;
                const oldTitle = data.currentNote;
                
                // If this was a pending new note and user has made ANY changes, clear the pending status
                if (data.pendingNewNote && 
                    data.pendingNewNote.folder === data.currentFolder && 
                    data.pendingNewNote.note === oldTitle) {
                    
                    // Clear pending status if user has made meaningful changes
                    const hasTitle = newTitle !== '' && newTitle !== 'New Note';
                    const hasBody = body.trim() !== '';
                    
                    if (hasTitle || hasBody) {
                        data.pendingNewNote = null;
                    }
                }
                
                // If title changed, we need to update the key in the data structure
                if (newTitle !== oldTitle && newTitle !== '') {
                    // Get the note data
                    const noteData = data.folders[data.currentFolder][oldTitle];
                    
                    // Delete the old key
                    delete data.folders[data.currentFolder][oldTitle];
                    
                    // Create new key with updated data
                    data.folders[data.currentFolder][newTitle] = {
                        title: newTitle,
                        body: body
                    };
                    
                    // Update current selection to new title
                    data.currentNote = newTitle;
                    
                    // Update pending new note reference if it exists
                    if (data.pendingNewNote && data.pendingNewNote.note === oldTitle) {
                        data.pendingNewNote.note = newTitle;
                    }
                } else {
                    // Title didn't change, just update the body
                    data.folders[data.currentFolder][data.currentNote].body = body;
                }
                
                renderFolders(); // Update sidebar to show changes
                updateDeleteButton(); // Update delete button tooltip
                saveData();
            }
        }

        function saveFolderData() {
            if (data.currentFolder && data.selectedType === 'folder') {
                const newName = document.getElementById('note-title').value.trim();
                const description = document.getElementById('editor').value;
                const oldName = data.currentFolder;
                
                // If this was a pending new folder and user has made changes, clear the pending status
                if (data.pendingNewFolder === oldName) {
                    const hasName = newName !== '' && newName !== 'New Folder';
                    const hasDescription = description.trim() !== '';
                    
                    if (hasName || hasDescription) {
                        data.pendingNewFolder = null;
                    }
                }
                
                // If folder name changed, we need to update the key in the data structure
                if (newName !== oldName && newName !== '') {
                    // Get the folder data
                    const folderNotes = data.folders[oldName];
                    const folderState = data.folderStates[oldName];
                    
                    // Delete the old keys
                    delete data.folders[oldName];
                    delete data.folderStates[oldName];
                    delete data.folderMetadata[oldName];
                    
                    // Create new keys with updated data
                    data.folders[newName] = folderNotes;
                    data.folderStates[newName] = folderState;
                    data.folderMetadata[newName] = {
                        name: newName,
                        description: description
                    };
                    
                    // Update current selection to new name
                    data.currentFolder = newName;
                    
                    // Update pending folder reference if it exists
                    if (data.pendingNewFolder === oldName) {
                        data.pendingNewFolder = newName;
                    }
                } else {
                    // Name didn't change, just update the description
                    if (!data.folderMetadata[data.currentFolder]) {
                        data.folderMetadata[data.currentFolder] = { name: data.currentFolder, description: '' };
                    }
                    data.folderMetadata[data.currentFolder].description = description;
                }
                
                renderFolders(); // Update sidebar to show changes
                updateDeleteButton(); // Update delete button tooltip
                saveData();
            }
        }

        function copyCurrentNote() {
            const content = document.getElementById('editor').value;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.querySelector('.copy-button');
                const textSpan = document.getElementById('copy-text');
                
                // Change appearance to show success
                btn.classList.add('copied');
                textSpan.textContent = 'Copied!';
                
                // Reset after 1.5 seconds
                setTimeout(() => {
                    btn.classList.remove('copied');
                    textSpan.textContent = 'Copy';
                }, 1500);
            }).catch(() => {
                // Fallback if clipboard API fails
                const btn = document.querySelector('.copy-button');
                const textSpan = document.getElementById('copy-text');
                
                textSpan.textContent = 'Failed';
                setTimeout(() => {
                    textSpan.textContent = 'Copy';
                }, 1500);
            });
        }

        function deleteCurrentNote() {
            if (data.selectedType === 'folder' && data.currentFolder) {
                deleteCurrentFolder();
            } else if (data.selectedType === 'note' && data.currentFolder && data.currentNote) {
                deleteCurrentNoteOnly();
            }
        }

        function deleteCurrentFolder() {
            const folderName = data.currentFolder;
            const noteCount = Object.keys(data.folders[folderName]).length;
            
            // Confirm deletion
            let confirmMessage = `Are you sure you want to delete the folder "${folderName}"?`;
            if (noteCount > 0) {
                confirmMessage += `\n\nThis will also delete ${noteCount} note${noteCount === 1 ? '' : 's'} inside it.`;
            }
            
            if (!confirm(confirmMessage)) {
                return;
            }

            // Remove the folder and its folder state
            delete data.folders[folderName];
            delete data.folderStates[folderName];

            // Find another folder/note to select
            let newSelection = null;
            const remainingFolders = Object.keys(data.folders);
            
            if (remainingFolders.length > 0) {
                const firstFolder = remainingFolders[0];
                const notesInFolder = Object.keys(data.folders[firstFolder]);
                
                if (notesInFolder.length > 0) {
                    // Select first note in first remaining folder
                    newSelection = {
                        type: 'note',
                        folder: firstFolder,
                        note: notesInFolder[0]
                    };
                } else {
                    // Select the folder itself
                    newSelection = {
                        type: 'folder',
                        folder: firstFolder,
                        note: null
                    };
                }
            }

            // Update selection
            if (newSelection) {
                data.currentFolder = newSelection.folder;
                data.currentNote = newSelection.note;
                data.selectedType = newSelection.type;
                
                if (newSelection.type === 'note') {
                    selectNote(newSelection.folder, newSelection.note);
                } else {
                    selectFolder(newSelection.folder);
                }
            } else {
                // No folders left, clear everything
                data.currentFolder = null;
                data.currentNote = null;
                data.selectedType = 'note';
                document.getElementById('note-title').value = '';
                document.getElementById('editor').value = '';
                document.getElementById('preview').innerHTML = '';
                renderFolders();
            }

            updateDeleteButton();
            saveData();
        }

        function deleteCurrentNoteOnly() {
            if (!data.currentFolder || !data.currentNote) {
                return; // No note selected
            }

            // Confirm deletion
            if (!confirm(`Are you sure you want to delete "${data.currentNote}"?`)) {
                return;
            }

            // Remove the note
            delete data.folders[data.currentFolder][data.currentNote];

            // Find another note to select, or clear the editor
            let newSelection = null;
            
            // First try to find another note in the same folder
            const remainingNotes = Object.keys(data.folders[data.currentFolder]);
            if (remainingNotes.length > 0) {
                newSelection = {
                    type: 'note',
                    folder: data.currentFolder,
                    note: remainingNotes[0]
                };
            } else {
                // No notes left in folder, select the folder itself
                newSelection = {
                    type: 'folder',
                    folder: data.currentFolder,
                    note: null
                };
            }

            // Update selection
            if (newSelection.type === 'note') {
                selectNote(newSelection.folder, newSelection.note);
            } else {
                selectFolder(newSelection.folder);
            }

            updateDeleteButton();
            saveData();
        }

        function updateDeleteButton() {
            const deleteBtn = document.getElementById('bottom-delete-button');
            
            if (data.selectedType === 'folder' && data.currentFolder) {
                deleteBtn.disabled = false;
                const noteCount = Object.keys(data.folders[data.currentFolder]).length;
                deleteBtn.title = `Delete folder "${data.currentFolder}"${noteCount > 0 ? ` (${noteCount} notes)` : ''}`;
            } else if (data.selectedType === 'note' && data.currentFolder && data.currentNote) {
                deleteBtn.disabled = false;
                deleteBtn.title = `Delete note "${data.currentNote}"`;
            } else {
                deleteBtn.disabled = true;
                deleteBtn.title = 'No note or folder selected';
            }
        }

        // Event listeners
        document.getElementById('note-title').addEventListener('input', saveCurrentNote);
        document.getElementById('editor').addEventListener('input', function(e) {
            updatePreview();
            saveCurrentNote();
            
            // Command palette logic
            const pos = e.target.selectionStart;
            const text = e.target.value;
            const beforeCursor = text.substr(0, pos);
            const lastSlash = beforeCursor.lastIndexOf('/');
            
            if (lastSlash !== -1) {
                const afterSlash = beforeCursor.substr(lastSlash + 1);
                if (afterSlash.indexOf(' ') === -1 && afterSlash.indexOf('\n') === -1) {
                    paletteQuery = afterSlash;
                    palettePosition = pos;
                    showCommandPalette(afterSlash, pos);
                    return;
                }
            }
            
            if (paletteVisible) {
                hideCommandPalette();
            }
        });

        document.getElementById('editor').addEventListener('keydown', function(e) {
            if (paletteVisible) {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = document.querySelectorAll('.palette-item');
                    paletteIndex = Math.min(paletteIndex + 1, items.length - 1);
                    items.forEach((item, i) => item.classList.toggle('selected', i === paletteIndex));
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const items = document.querySelectorAll('.palette-item');
                    paletteIndex = Math.max(paletteIndex - 1, 0);
                    items.forEach((item, i) => item.classList.toggle('selected', i === paletteIndex));
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const selectedItem = document.querySelector('.palette-item.selected');
                    if (selectedItem) {
                        selectedItem.click();
                    }
                } else if (e.key === 'Escape') {
                    hideCommandPalette();
                }
            }
        });

        document.addEventListener('click', function(e) {
            if (paletteVisible && !document.getElementById('command-palette').contains(e.target)) {
                hideCommandPalette();
            }
        });

        // Command palette
        function showCommandPalette(query, position) {
            const allNotes = [];
            Object.keys(data.folders).forEach(folder => {
                Object.keys(data.folders[folder]).forEach(noteTitle => {
                    if (noteTitle !== data.currentNote) { // Don't show current note
                        allNotes.push({
                            folder,
                            title: noteTitle,
                            note: data.folders[folder][noteTitle]
                        });
                    }
                });
            });

            // Fuzzy search
            const filtered = allNotes.filter(item => 
                item.title.toLowerCase().includes(query.toLowerCase())
            ).slice(0, 5);

            const palette = document.getElementById('command-palette');
            
            if (filtered.length === 0) {
                palette.style.display = 'none';
                paletteVisible = false;
                return;
            }

            palette.innerHTML = '';
            filtered.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'palette-item';
                if (index === paletteIndex) div.classList.add('selected');
                div.textContent = item.title;
                div.onclick = () => insertReference(item.note);
                palette.appendChild(div);
            });

            // Position palette
            const editor = document.getElementById('editor');
            const rect = editor.getBoundingClientRect();
            const lines = editor.value.substr(0, position).split('\n');
            const lineHeight = 22; // Approximate line height
            
            palette.style.display = 'block';
            palette.style.left = '40px';
            palette.style.top = (lines.length * lineHeight + 60) + 'px';
            
            paletteVisible = true;
        }

        function insertReference(note) {
            const editor = document.getElementById('editor');
            const pos = editor.selectionStart;
            const text = editor.value;
            
            // Find the "/" character position
            const beforeCursor = text.substr(0, pos);
            const slashPos = beforeCursor.lastIndexOf('/');
            
            const reference = `{{${note.title}\n---\n${note.body}}}`;
            const newText = text.substring(0, slashPos) + reference + text.substring(pos);
            
            editor.value = newText;
            editor.focus();
            editor.setSelectionRange(slashPos + reference.length, slashPos + reference.length);
            
            hideCommandPalette();
            updatePreview();
            saveCurrentNote();
        }

        function hideCommandPalette() {
            document.getElementById('command-palette').style.display = 'none';
            paletteVisible = false;
            paletteIndex = -1;
        }

        function showHelpModal() {
            document.getElementById('help-modal').style.display = 'flex';
        }

        function hideHelpModal() {
            document.getElementById('help-modal').style.display = 'none';
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                hideHelpModal();
            }
        });

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                sidebar.classList.toggle('open');
            } else {
                sidebar.classList.toggle('collapsed');
            }
        }

        function showPreview() {
            const previewPane = document.getElementById('preview-pane');
            previewPane.classList.add('show');
        }

        function hidePreview() {
            const previewPane = document.getElementById('preview-pane');
            previewPane.classList.remove('show');
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(e) {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile && sidebar.classList.contains('open')) {
                if (!sidebar.contains(e.target) && e.target !== sidebarToggle) {
                    sidebar.classList.remove('open');
                }
            }
            
            if (paletteVisible && !document.getElementById('command-palette').contains(e.target)) {
                hideCommandPalette();
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            const sidebar = document.getElementById('sidebar');
            const isMobile = window.innerWidth <= 768;
            
            if (!isMobile) {
                sidebar.classList.remove('open');
            }
        });

        // Initialize app
        loadData();
        renderFolders();
        if (data.currentFolder && data.currentNote) {
            selectNote(data.currentFolder, data.currentNote);
        }
        updateDeleteButton();
    </script>
</body>
</html> 